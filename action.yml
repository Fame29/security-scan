name: 'ZeriFlow Security Scan'
description: 'AI-powered security scanner for your pull requests. Checks secrets, vulnerabilities, auth issues, and more.'
author: 'ZeriFlow'

branding:
  icon: 'shield'
  color: 'white'

inputs:
  api-key:
    description: 'Your ZeriFlow API key (get it from zeriflow.com/dashboard/ci)'
    required: true
  api-url:
    description: 'ZeriFlow API endpoint (override for self-hosted)'
    required: false
    default: ''
  threshold:
    description: 'Minimum security score to pass (0-100, default: uses project setting)'
    required: false
    default: ''
  fail-on-critical:
    description: 'Fail the check if any critical issue is found, regardless of score'
    required: false
    default: 'true'
  comment:
    description: 'Post results as a PR comment'
    required: false
    default: 'true'

outputs:
  score:
    description: 'Security score (0-100)'
    value: ${{ steps.scan.outputs.score }}
  passed:
    description: 'Whether the scan passed (true/false)'
    value: ${{ steps.scan.outputs.passed }}
  critical-count:
    description: 'Number of critical findings'
    value: ${{ steps.scan.outputs.critical-count }}
  warning-count:
    description: 'Number of warning findings'
    value: ${{ steps.scan.outputs.warning-count }}
  scan-id:
    description: 'ZeriFlow scan ID for reference'
    value: ${{ steps.scan.outputs.scan-id }}

runs:
  using: 'composite'
  steps:
    - name: Install Semgrep
      shell: bash
      run: pip install semgrep --quiet 2>/dev/null

    - name: Install Gitleaks
      shell: bash
      run: |
        GITLEAKS_VERSION="8.18.2"
        curl -sSfL "https://github.com/gitleaks/gitleaks/releases/download/v${GITLEAKS_VERSION}/gitleaks_${GITLEAKS_VERSION}_linux_x64.tar.gz" | tar xz -C /usr/local/bin gitleaks 2>/dev/null || echo "Gitleaks install failed, continuing without it"

    - name: Collect PR diff
      id: diff
      shell: bash
      run: |
        BASE_SHA="${{ github.event.pull_request.base.sha }}"
        HEAD_SHA="${{ github.event.pull_request.head.sha }}"
        if [ -z "$BASE_SHA" ] || [ -z "$HEAD_SHA" ]; then
          BASE_SHA="HEAD~1"
          HEAD_SHA="HEAD"
        fi
        git diff --name-only "$BASE_SHA"..."$HEAD_SHA" 2>/dev/null > /tmp/changed_files.txt || git diff --name-only HEAD~1 > /tmp/changed_files.txt

        node <<'NODESCRIPT'
        const fs = require('fs');
        const files = fs.readFileSync('/tmp/changed_files.txt', 'utf8').trim().split('\n').filter(Boolean);
        const diff_files = [];
        for (const f of files.slice(0, 50)) {
          try {
            const content = fs.readFileSync(f, 'utf8');
            if (content.length > 100000) continue;
            diff_files.push({ path: f, content, status: 'modified' });
          } catch {
            diff_files.push({ path: f, content: '', status: 'removed' });
          }
        }
        fs.writeFileSync('/tmp/diff_files.json', JSON.stringify(diff_files));
        console.log('Files collected: ' + diff_files.length);
        NODESCRIPT

    - name: Run Semgrep
      shell: bash
      continue-on-error: true
      run: semgrep scan --config auto --json --quiet > /tmp/semgrep_results.json 2>/dev/null || echo '{"results":[]}' > /tmp/semgrep_results.json

    - name: Run Gitleaks
      shell: bash
      continue-on-error: true
      run: gitleaks detect --source . --report-format json --report-path /tmp/gitleaks_results.json --no-banner 2>/dev/null || echo '[]' > /tmp/gitleaks_results.json

    - name: Run npm audit
      shell: bash
      continue-on-error: true
      run: |
        if [ -f package-lock.json ]; then
          npm audit --json > /tmp/npm_audit_results.json 2>/dev/null || echo '{}' > /tmp/npm_audit_results.json
        else
          echo '{}' > /tmp/npm_audit_results.json
        fi

    - name: Detect framework
      id: framework
      shell: bash
      run: |
        if [ -f package.json ]; then
          FRAMEWORK=$(node -e "
            const pkg = require('./package.json');
            const deps = {...(pkg.dependencies||{}), ...(pkg.devDependencies||{})};
            if (deps['next']) console.log('nextjs');
            else if (deps['nuxt']) console.log('nuxt');
            else if (deps['react']) console.log('react');
            else if (deps['vue']) console.log('vue');
            else if (deps['express']) console.log('express');
            else if (deps['fastify']) console.log('fastify');
            else console.log('unknown');
          " 2>/dev/null || echo "unknown")
          echo "framework=$FRAMEWORK" >> "$GITHUB_OUTPUT"
        elif [ -f requirements.txt ]; then
          if grep -qi django requirements.txt; then echo "framework=django" >> "$GITHUB_OUTPUT";
          elif grep -qi flask requirements.txt; then echo "framework=flask" >> "$GITHUB_OUTPUT";
          elif grep -qi fastapi requirements.txt; then echo "framework=fastapi" >> "$GITHUB_OUTPUT";
          else echo "framework=python" >> "$GITHUB_OUTPUT"; fi
        else
          echo "framework=unknown" >> "$GITHUB_OUTPUT"
        fi

    - name: Build payload and send to ZeriFlow
      id: scan
      shell: bash
      env:
        ZERIFLOW_API_KEY: ${{ inputs.api-key }}
        INPUT_API_URL: ${{ inputs.api-url }}
        PR_NUMBER: ${{ github.event.pull_request.number || 0 }}
        PR_TITLE: ${{ github.event.pull_request.title }}
        COMMIT_SHA: ${{ github.event.pull_request.head.sha || github.sha }}
        BRANCH: ${{ github.head_ref || github.ref_name }}
        FRAMEWORK: ${{ steps.framework.outputs.framework }}
        GITHUB_OUTPUT_FILE: ${{ github.output }}
      run: |
        node <<'NODESCRIPT'
        const fs = require('fs');
        const { execSync } = require('child_process');

        // Build payload entirely in Node (no bash variable expansion issues)
        let pkgJson = null;
        try { pkgJson = JSON.parse(fs.readFileSync('package.json', 'utf8')); } catch {}

        const payload = {
          pr_number: parseInt(process.env.PR_NUMBER) || 0,
          pr_title: process.env.PR_TITLE || '',
          commit_sha: process.env.COMMIT_SHA || '',
          branch: process.env.BRANCH || '',
          diff_files: JSON.parse(fs.readFileSync('/tmp/diff_files.json', 'utf8')),
          static_findings: {
            semgrep: JSON.parse(fs.readFileSync('/tmp/semgrep_results.json', 'utf8')),
            gitleaks: JSON.parse(fs.readFileSync('/tmp/gitleaks_results.json', 'utf8')),
            npm_audit: JSON.parse(fs.readFileSync('/tmp/npm_audit_results.json', 'utf8'))
          },
          package_json: pkgJson,
          framework_detected: process.env.FRAMEWORK || 'unknown'
        };

        fs.writeFileSync('/tmp/zf_payload.json', JSON.stringify(payload));
        console.log('Payload built: ' + JSON.stringify(payload).length + ' bytes');
        NODESCRIPT

        API_URL="${INPUT_API_URL}"
        if [ -z "$API_URL" ]; then
          API_URL="https://nkkfvjqcbniylnwmviyf.supabase.co/functions/v1/ci-scan"
        fi

        echo "Sending to $API_URL ..."

        for attempt in 1 2 3; do
          HTTP_CODE=$(curl -s -o /tmp/scan_result.json -w "%{http_code}" \
            -X POST "$API_URL" \
            -H "Content-Type: application/json" \
            -H "X-API-Key: $ZERIFLOW_API_KEY" \
            -d @/tmp/zf_payload.json \
            --max-time 120)

          echo "Attempt $attempt: HTTP $HTTP_CODE"

          if [ "$HTTP_CODE" = "200" ]; then
            break
          elif [ "$HTTP_CODE" = "402" ]; then
            echo "::error::No CI/CD scans remaining. Buy tokens at https://zeriflow.com/pricing"
            exit 1
          elif [ "$attempt" -lt 3 ] && [ "$HTTP_CODE" -ge "500" ] 2>/dev/null; then
            echo "Server error, retrying in 10s..."
            sleep 10
          else
            BODY=$(cat /tmp/scan_result.json 2>/dev/null || echo "no response")
            echo "::error::ZeriFlow scan failed (HTTP $HTTP_CODE): $BODY"
            exit 1
          fi
        done

        node <<'NODESCRIPT'
        const fs = require('fs');
        const r = JSON.parse(fs.readFileSync('/tmp/scan_result.json', 'utf8'));
        const out = process.env.GITHUB_OUTPUT;
        const lines = [
          `score=${r.score || 0}`,
          `passed=${r.passed || false}`,
          `critical-count=${r.critical_count || 0}`,
          `warning-count=${r.warning_count || 0}`,
          `scan-id=${r.scan_id || ''}`
        ];
        fs.appendFileSync(out, lines.join('\n') + '\n');
        console.log('Score: ' + (r.score || 0) + '/100 â€” ' + (r.passed ? 'PASSED' : 'FAILED'));
        NODESCRIPT

    - name: Post PR comment
      if: ${{ inputs.comment == 'true' && github.event_name == 'pull_request' }}
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
        REPO: ${{ github.repository }}
      run: |
        node <<'NODESCRIPT'
        const fs = require('fs');
        const { execSync } = require('child_process');

        const r = JSON.parse(fs.readFileSync('/tmp/scan_result.json', 'utf8'));
        const score = r.score || 0;
        const passed = r.passed || false;
        const critical = r.critical_count || 0;
        const warning = r.warning_count || 0;
        const info = r.info_count || 0;
        const summary = r.summary || '';
        const threshold = r.threshold || 60;
        const scanId = r.scan_id || '';
        const statusIcon = passed ? 'âœ…' : 'âŒ';
        const statusText = passed ? 'PASSED' : 'FAILED';

        const findings = r.findings || [];
        const icons = { critical: 'ðŸ”´', warning: 'ðŸŸ¡', info: 'ðŸ”µ' };
        let findingsMd = 'No issues found!';
        if (findings.length > 0) {
          const lines = findings.slice(0, 20).map(f =>
            `${icons[f.severity] || 'âšª'} **${(f.severity||'info').toUpperCase()}**: ${f.title} (\`${f.file}${f.line ? ':'+f.line : ''}\`)`
          );
          if (findings.length > 20) lines.push(`... and ${findings.length - 20} more`);
          findingsMd = lines.join('\n');
        }

        let quotaMd = '';
        const q = r.quota || {};
        if (q.source === 'tokens') quotaMd = `_Scan paid with 1 token. Balance: ${q.token_balance} tokens remaining._`;
        else if (q.source === 'plan') quotaMd = `_Plan scan. ${q.remaining_plan} free scans remaining this month._`;

        const comment = `## ${statusIcon} ZeriFlow Security Scan â€” ${statusText}

**Score: ${score}/100** | Threshold: ${threshold} | ${critical} critical Â· ${warning} warnings Â· ${info} info

${summary}

### Findings

${findingsMd}

---
${quotaMd}
[View full report](https://zeriflow.com/dashboard/ci/scan/${scanId}) Â· Powered by [ZeriFlow](https://zeriflow.com)`;

        // Check for existing comment to update
        const prNumber = process.env.PR_NUMBER;
        const repo = process.env.REPO;
        try {
          const existing = execSync(
            `gh api "repos/${repo}/issues/${prNumber}/comments" --jq '.[] | select(.body | startswith("## âœ… ZeriFlow") or startswith("## âŒ ZeriFlow")) | .id' 2>/dev/null`,
            { encoding: 'utf8' }
          ).trim().split('\n')[0];

          if (existing) {
            execSync(`gh api "repos/${repo}/issues/comments/${existing}" -X PATCH -f body=@-`, { input: comment });
          } else {
            execSync(`gh pr comment ${prNumber} --body-file -`, { input: comment });
          }
        } catch {
          try { execSync(`gh pr comment ${prNumber} --body-file -`, { input: comment }); } catch {}
        }
        console.log('PR comment posted');
        NODESCRIPT

    - name: Check result
      shell: bash
      run: |
        PASSED="${{ steps.scan.outputs.passed }}"
        CRITICAL="${{ steps.scan.outputs.critical-count }}"
        FAIL_ON_CRITICAL="${{ inputs.fail-on-critical }}"

        if [ "$PASSED" = "false" ]; then
          echo "::error::ZeriFlow security check failed. Score below threshold."
          exit 1
        fi

        if [ "$FAIL_ON_CRITICAL" = "true" ] && [ "$CRITICAL" -gt "0" ]; then
          echo "::error::ZeriFlow found $CRITICAL critical issue(s)."
          exit 1
        fi

        echo "ZeriFlow security check passed"
