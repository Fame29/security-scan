name: 'ZeriFlow Security Scan'
description: 'AI-powered security scanner for your pull requests. Checks secrets, vulnerabilities, auth issues, and more.'
author: 'ZeriFlow'

branding:
  icon: 'shield'
  color: 'white'

inputs:
  api-key:
    description: 'Your ZeriFlow API key (get it from zeriflow.com/dashboard/ci)'
    required: true
  api-url:
    description: 'ZeriFlow API endpoint (override for self-hosted)'
    required: false
    default: ''
  threshold:
    description: 'Minimum security score to pass (0-100, default: uses project setting)'
    required: false
    default: ''
  fail-on-critical:
    description: 'Fail the check if any critical issue is found, regardless of score'
    required: false
    default: 'true'
  comment:
    description: 'Post results as a PR comment'
    required: false
    default: 'true'

outputs:
  score:
    description: 'Security score (0-100)'
    value: ${{ steps.scan.outputs.score }}
  passed:
    description: 'Whether the scan passed (true/false)'
    value: ${{ steps.scan.outputs.passed }}
  critical-count:
    description: 'Number of critical findings'
    value: ${{ steps.scan.outputs.critical-count }}
  warning-count:
    description: 'Number of warning findings'
    value: ${{ steps.scan.outputs.warning-count }}
  scan-id:
    description: 'ZeriFlow scan ID for reference'
    value: ${{ steps.scan.outputs.scan-id }}

runs:
  using: 'composite'
  steps:
    # Step 1: Install static analysis tools
    - name: Install Semgrep
      shell: bash
      run: pip install semgrep --quiet 2>/dev/null

    - name: Install Gitleaks
      shell: bash
      run: |
        GITLEAKS_VERSION="8.18.2"
        curl -sSfL "https://github.com/gitleaks/gitleaks/releases/download/v${GITLEAKS_VERSION}/gitleaks_${GITLEAKS_VERSION}_linux_x64.tar.gz" | tar xz -C /usr/local/bin gitleaks 2>/dev/null || echo "Gitleaks install failed, continuing without it"

    # Step 2: Collect PR diff
    - name: Collect PR diff
      id: diff
      shell: bash
      run: |
        BASE_SHA="${{ github.event.pull_request.base.sha }}"
        HEAD_SHA="${{ github.event.pull_request.head.sha }}"

        if [ -z "$BASE_SHA" ] || [ -z "$HEAD_SHA" ]; then
          echo "Not a pull request event, using last commit diff"
          BASE_SHA="HEAD~1"
          HEAD_SHA="HEAD"
        fi

        git diff --name-only "$BASE_SHA"..."$HEAD_SHA" 2>/dev/null > /tmp/changed_files.txt || git diff --name-only HEAD~1 > /tmp/changed_files.txt

        node -e "
        const fs = require('fs');
        const files = fs.readFileSync('/tmp/changed_files.txt', 'utf8').trim().split('\n').filter(Boolean);
        const diff_files = [];
        for (const f of files.slice(0, 50)) {
          try {
            const content = fs.readFileSync(f, 'utf8');
            if (content.length > 100000) continue;
            diff_files.push({ path: f, content, status: 'modified' });
          } catch {
            diff_files.push({ path: f, content: '', status: 'removed' });
          }
        }
        fs.writeFileSync('/tmp/diff_files.json', JSON.stringify(diff_files));
        console.log('Files collected: ' + diff_files.length);
        "

    # Step 3: Run static analysis
    - name: Run Semgrep
      shell: bash
      continue-on-error: true
      run: |
        semgrep scan --config auto --json --quiet > /tmp/semgrep_results.json 2>/dev/null || echo '{"results":[]}' > /tmp/semgrep_results.json

    - name: Run Gitleaks
      shell: bash
      continue-on-error: true
      run: |
        gitleaks detect --source . --report-format json --report-path /tmp/gitleaks_results.json --no-banner 2>/dev/null || echo '[]' > /tmp/gitleaks_results.json

    - name: Run npm audit
      shell: bash
      continue-on-error: true
      run: |
        if [ -f package-lock.json ]; then
          npm audit --json > /tmp/npm_audit_results.json 2>/dev/null || echo '{}' > /tmp/npm_audit_results.json
        else
          echo '{}' > /tmp/npm_audit_results.json
        fi

    # Step 4: Detect framework
    - name: Detect framework
      id: framework
      shell: bash
      run: |
        if [ -f package.json ]; then
          FRAMEWORK=$(node -e "
            const pkg = require('./package.json');
            const deps = {...(pkg.dependencies||{}), ...(pkg.devDependencies||{})};
            if (deps['next']) console.log('nextjs');
            else if (deps['nuxt']) console.log('nuxt');
            else if (deps['@sveltejs/kit']) console.log('sveltekit');
            else if (deps['react']) console.log('react');
            else if (deps['vue']) console.log('vue');
            else if (deps['express']) console.log('express');
            else if (deps['fastify']) console.log('fastify');
            else if (deps['django']) console.log('django');
            else if (deps['flask']) console.log('flask');
            else console.log('unknown');
          " 2>/dev/null || echo "unknown")
          echo "framework=$FRAMEWORK" >> "$GITHUB_OUTPUT"
        elif [ -f requirements.txt ]; then
          if grep -qi django requirements.txt; then echo "framework=django" >> "$GITHUB_OUTPUT";
          elif grep -qi flask requirements.txt; then echo "framework=flask" >> "$GITHUB_OUTPUT";
          elif grep -qi fastapi requirements.txt; then echo "framework=fastapi" >> "$GITHUB_OUTPUT";
          else echo "framework=python" >> "$GITHUB_OUTPUT"; fi
        else
          echo "framework=unknown" >> "$GITHUB_OUTPUT"
        fi

    # Step 5: Send to ZeriFlow API
    - name: Send to ZeriFlow
      id: scan
      shell: bash
      env:
        ZERIFLOW_API_KEY: ${{ inputs.api-key }}
      run: |
        PACKAGE_JSON="null"
        if [ -f package.json ]; then
          PACKAGE_JSON=$(cat package.json)
        fi

        PR_TITLE="${{ github.event.pull_request.title }}"
        PR_TITLE_ESCAPED=$(node -e "process.stdout.write(JSON.stringify(process.argv[1]))" -- "$PR_TITLE")

        PAYLOAD=$(node -e "
        const fs = require('fs');
        const payload = {
          pr_number: ${{ github.event.pull_request.number || 0 }},
          pr_title: $PR_TITLE_ESCAPED,
          commit_sha: '${{ github.event.pull_request.head.sha || github.sha }}',
          branch: '${{ github.head_ref || github.ref_name }}',
          diff_files: JSON.parse(fs.readFileSync('/tmp/diff_files.json', 'utf8')),
          static_findings: {
            semgrep: JSON.parse(fs.readFileSync('/tmp/semgrep_results.json', 'utf8')),
            gitleaks: JSON.parse(fs.readFileSync('/tmp/gitleaks_results.json', 'utf8')),
            npm_audit: JSON.parse(fs.readFileSync('/tmp/npm_audit_results.json', 'utf8'))
          },
          package_json: ${PACKAGE_JSON === "null" ? "null" : "JSON.parse(fs.readFileSync('package.json', 'utf8'))"},
          framework_detected: '${{ steps.framework.outputs.framework }}'
        };
        process.stdout.write(JSON.stringify(payload));
        ")

        API_URL="${{ inputs.api-url }}"
        if [ -z "$API_URL" ]; then
          API_URL="https://nkkfvjqcbniylnwmviyf.supabase.co/functions/v1/ci-scan"
        fi

        for attempt in 1 2 3; do
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            -X POST "$API_URL" \
            -H "Content-Type: application/json" \
            -H "X-API-Key: $ZERIFLOW_API_KEY" \
            -d "$PAYLOAD" \
            --max-time 120)

          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" = "200" ]; then
            echo "$BODY" > /tmp/scan_result.json
            break
          elif [ "$HTTP_CODE" = "402" ]; then
            echo "::error::No CI/CD scans remaining. Buy tokens at https://zeriflow.com/pricing"
            exit 1
          elif [ "$attempt" -lt 3 ]; then
            echo "Attempt $attempt failed (HTTP $HTTP_CODE), retrying in 10s..."
            sleep 10
          else
            echo "::error::ZeriFlow scan failed after 3 attempts (HTTP $HTTP_CODE): $BODY"
            exit 1
          fi
        done

        SCORE=$(node -e "console.log(JSON.parse(require('fs').readFileSync('/tmp/scan_result.json','utf8')).score || 0)")
        PASSED=$(node -e "console.log(JSON.parse(require('fs').readFileSync('/tmp/scan_result.json','utf8')).passed || false)")
        CRITICAL=$(node -e "console.log(JSON.parse(require('fs').readFileSync('/tmp/scan_result.json','utf8')).critical_count || 0)")
        WARNING=$(node -e "console.log(JSON.parse(require('fs').readFileSync('/tmp/scan_result.json','utf8')).warning_count || 0)")
        SCAN_ID=$(node -e "console.log(JSON.parse(require('fs').readFileSync('/tmp/scan_result.json','utf8')).scan_id || '')")

        echo "score=$SCORE" >> "$GITHUB_OUTPUT"
        echo "passed=$PASSED" >> "$GITHUB_OUTPUT"
        echo "critical-count=$CRITICAL" >> "$GITHUB_OUTPUT"
        echo "warning-count=$WARNING" >> "$GITHUB_OUTPUT"
        echo "scan-id=$SCAN_ID" >> "$GITHUB_OUTPUT"

    # Step 6: Post PR comment
    - name: Post PR comment
      if: ${{ inputs.comment == 'true' && github.event_name == 'pull_request' }}
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        RESULT=$(cat /tmp/scan_result.json)

        SCORE=$(node -e "const r=JSON.parse(require('fs').readFileSync('/tmp/scan_result.json','utf8')); process.stdout.write(String(r.score||0))")
        PASSED=$(node -e "const r=JSON.parse(require('fs').readFileSync('/tmp/scan_result.json','utf8')); process.stdout.write(String(r.passed||false))")
        CRITICAL=$(node -e "const r=JSON.parse(require('fs').readFileSync('/tmp/scan_result.json','utf8')); process.stdout.write(String(r.critical_count||0))")
        WARNING=$(node -e "const r=JSON.parse(require('fs').readFileSync('/tmp/scan_result.json','utf8')); process.stdout.write(String(r.warning_count||0))")
        INFO=$(node -e "const r=JSON.parse(require('fs').readFileSync('/tmp/scan_result.json','utf8')); process.stdout.write(String(r.info_count||0))")
        SUMMARY=$(node -e "const r=JSON.parse(require('fs').readFileSync('/tmp/scan_result.json','utf8')); process.stdout.write(r.summary||'')")
        THRESHOLD=$(node -e "const r=JSON.parse(require('fs').readFileSync('/tmp/scan_result.json','utf8')); process.stdout.write(String(r.threshold||60))")
        SCAN_ID=$(node -e "const r=JSON.parse(require('fs').readFileSync('/tmp/scan_result.json','utf8')); process.stdout.write(r.scan_id||'')")

        if [ "$PASSED" = "true" ]; then
          STATUS_ICON="âœ…"
          STATUS_TEXT="PASSED"
        else
          STATUS_ICON="âŒ"
          STATUS_TEXT="FAILED"
        fi

        FINDINGS_MD=$(node -e "
        const r = JSON.parse(require('fs').readFileSync('/tmp/scan_result.json','utf8'));
        const findings = r.findings || [];
        if (findings.length === 0) { process.stdout.write('No issues found!'); process.exit(); }
        const icons = { critical: 'ðŸ”´', warning: 'ðŸŸ¡', info: 'ðŸ”µ' };
        const lines = findings.slice(0, 20).map(f =>
          (icons[f.severity] || 'âšª') + ' **' + (f.severity||'info').toUpperCase() + '**: ' + f.title + ' (\`' + f.file + (f.line ? ':' + f.line : '') + '\`)'
        );
        if (findings.length > 20) lines.push('... and ' + (findings.length - 20) + ' more');
        process.stdout.write(lines.join('\n'));
        ")

        QUOTA_MD=$(node -e "
        const r = JSON.parse(require('fs').readFileSync('/tmp/scan_result.json','utf8'));
        const q = r.quota || {};
        if (q.source === 'tokens') process.stdout.write('_Scan paid with 1 token. Balance: ' + q.token_balance + ' tokens remaining._');
        else if (q.source === 'plan') process.stdout.write('_Plan scan. ' + q.remaining_plan + ' free scans remaining this month._');
        else process.stdout.write('');
        ")

        COMMENT=$(cat <<ZFEOF
        ## $STATUS_ICON ZeriFlow Security Scan â€” $STATUS_TEXT

        **Score: $SCORE/100** | Threshold: $THRESHOLD | $CRITICAL critical Â· $WARNING warnings Â· $INFO info

        $SUMMARY

        ### Findings

        $FINDINGS_MD

        ---
        $QUOTA_MD
        [View full report](https://zeriflow.com/dashboard/ci/scan/$SCAN_ID) Â· Powered by [ZeriFlow](https://zeriflow.com)
        ZFEOF
        )

        EXISTING_COMMENT_ID=$(gh api "repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments" --jq '.[] | select(.body | startswith("## âœ… ZeriFlow") or startswith("## âŒ ZeriFlow")) | .id' 2>/dev/null | head -1)

        if [ -n "$EXISTING_COMMENT_ID" ]; then
          gh api "repos/${{ github.repository }}/issues/comments/$EXISTING_COMMENT_ID" -X PATCH -f body="$COMMENT" 2>/dev/null || true
        else
          gh pr comment "${{ github.event.pull_request.number }}" --body "$COMMENT" 2>/dev/null || true
        fi

    # Step 7: Check result
    - name: Check result
      shell: bash
      run: |
        PASSED="${{ steps.scan.outputs.passed }}"
        CRITICAL="${{ steps.scan.outputs.critical-count }}"
        FAIL_ON_CRITICAL="${{ inputs.fail-on-critical }}"

        if [ "$PASSED" = "false" ]; then
          echo "::error::ZeriFlow security check failed. Score below threshold."
          exit 1
        fi

        if [ "$FAIL_ON_CRITICAL" = "true" ] && [ "$CRITICAL" -gt "0" ]; then
          echo "::error::ZeriFlow found $CRITICAL critical issue(s)."
          exit 1
        fi

        echo "ZeriFlow security check passed"
